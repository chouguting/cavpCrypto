
#include "stdio.h"
#include "string.h"
#include "myEcdsa.h"
#include "mySha.h"

// Visual Studio 有BUG，從Github上下載本專案後會無法編譯
// 解決方法：Windows偵錯工具右邊有個下拉選單，選擇cavpCrypto偵錯屬性，把C語言標準調成比較新的，就可以編譯了
// 很奇怪的是，如果你編譯成功後，再把C語言標準調回原本的，再編譯一次，也會成功 (很奇怪吧😶😶😶😶😶)

int main()
{
	/*
	char* message = "7E6C382C0D6DEF2B180B4417995AF4D25151B84E614FEDC4D7931DCB71B4331577ED61804A5F8D531D5C01FBED2E958F2029BBD1053FB9DFED828C9BC00D87190632462EEA14FB0C23BE8E1A2EDB47632FDDD9F9CD3A47BD1B4B95466CB111AC762FD63492C46DF923890C4CFCD42B83C8F84CD2B9FE49DC66D8F2570E1F952F";
	char* d = "012FC9BC24B7733246456C5EB6F8A45AA9CAB7889AAB5B11B5751C46F1A476B5DF777E65D11600FB966B2D139C96124DD0DE4655D789E62B3B9A64D084FAE05A5DFF";
	int keypairCurve = ECDSA_CURVE_P521;
	ecdsaSignatureGenerate(ECDSA_CURVE_P521, ECDSA_HASH_SHAKE256, d, message);


	char* qx = "0091699D14832AFB5189F9759174654CB4881E2E9E2C2FA0CBA266B3837C100D17DCB0EB302683FDE071A682B4211A052D752D5165670DC294A017C6AA9944E3FD22";
	char* qy = "21E8089C5D826CEBE5653329040EA340E534C0819A108C061F01101DE0A7AD31FB23F02641DFD80724C3BCD9F81E4E0F53E08046116C520E689CFE7638AC3911F3";

	
	char* r = "E50315FEFB872D5C2CBBB149111897A3868DCEF8CB65B2424E0CBA4446A45A8EB90C4D9C025456A5BA8A1BED11AC67FA0879A18584935CF4C8409D1DB71F10F44D";
	char* s = "193617EAFC1553E3EDEDB456E1311103131925F96DAC826BA3C2D5E43264F03BCE629AC43974D91FABE305C48A134E99E246FD9F4C335C0A80A71A9B2E6F3AFFA9A";
	*/
	char* message = "50FACF2893C15BC1D0B8652DBA1F133A8D47D6F9D4F13BAF1755D7BAD5AFA9C01BA3FE4B0B6B17BB884116F946B621073233AE514E06E94E46DA94AB7DE402E7B1ACE3DC26466E3C9825FFBD40828AAC00549FD8975A6CFF7F249279A8B0E088FF577BD162225BD10B46ABBB056873D8543C5B5E6C023E2C7D46FE8218798244E00526B45ADFE85CB20BDAD587EA457EA7AAF32BF4C18D250CD6B04B7E0EDDE51B33A64AE71B824768501FFA274A032E917D90F65F9E78864F0DCFDD2650ACD10601208A19D6FC37A052C96C48DD33DBB4D79C2BE0E4E73CBEBF20E452239A31BD67D75A26B7052DA970DA46DB364670F12200C0826939DE5C47421F04A5A87A99A5A38E4D25FEB5971E9419C2448400DE2589FB9D33D760F62580256C9D4C3E8A9D8B5F3725957B1E9EF459C92F04DD6DAFBC50E332182404DAB4E3A11C538C785E48C721F1B09B756D2DB558DB3AAA092142C029C59CD264AC51E7C00BE94C544C3504D90DFEAF70E61580057CD055C275EE8A68A8D8AE6322D41FA120818BEE33322931FC1FF7ABAB68027300F539CBF2074296D77F87756601F904AA5AD9E88980FBB69C47CAB78461E82F4E15641CD9C9FBF969146E2EE8C579C6D77C0D9398508864121295EE01ABAB45AD703BE0C8D081B7EE713811E50DC93236CB6330A7969F89F52DED5A80EA6AA226543BB1F8AF923AACB42937DA7E92FF6D16D86C4ED19AE922338F5A0B2D6B17A9128F770C36490E37B101417FC1BD8587F888EC0114B5B6CB47E841BDCAEBADF5A8F9970319F7F602D980038766310A754D24F6DB61C0A2AA9391042D4CE7B8B488A7B0CC32D2ACEF644DC1B75F495D4C158DA582A0369D59C5CAD6C6E65A509B3863D1C37D2002F2A79712FE1968746957EB879C82F0185A6B2DEC35C55486764BDB20D4B3B5379D2A2773B8900887B2009B1A6DD19B7658388479B4BD2D1A1A4FA306A01B750572585938F84850DEE4E2AA62DF6FD51A517B3B49B8288FF66220BB086FEC695D627B8943EBEDF293823DA143B48F3BD65812F30A78D880FC9B4425EADCD21C85265FF21A452E2C4486B32239242A3B880B98DB8B728FBC5596CF7118327847A476C56EF018476F339E659A342D16CC0C5D58632376924B944F0A62B561CBAA20E84F4FF03799E06FBB521EBD240B60F884D3E3DC992FF3C6B6A689F9B62B85BC22BE3F8D0E50E04135FC536A59013AD80318E0E787CCDF28DD5E4117DA166B0FBC77BE5FE4631064BB6BA978";
	char* r = "001B5352331CCF95E7DE5B8CCE856079A413A6333EE762833FD78922F0DB292A395F9E4472E981B4E58AC41CD87804FE100AA9779FFC39DC6FE80A49F08B85223FDD";
	char* s = "00A3889746E71F96AB2CA59C1E24AABE028A7619A85319E57DD25C73685452A544AFCE6B63F0CA225F6E0D0A01D795508D4D6724ECCBB5F94F6CBFE66DDBB89B935A";
	char* qx = "00A76876E1E5E232C57293C52CF90E70C486309B5D54BEBF2E52C97E5BE9F28DF21445B63433E57EF8428036E596E4934D8B4524443B90619D9465EC2ADCAE338C86";
	char* qy = "00533859E5A96420E7FC13B4C731C6AEEFFB4D0852EF1D7EB46E71FEDF701CB8EA61CC0D63B82E1B62DB35CC797D41C005091EEC6CDEE80BD7070F391AE7F84840FC";



	int result = ecdsaSignatureVerify(ECDSA_CURVE_P521, ECDSA_HASH_SHA2_256, qx, qy, r, s, message);

	if (result == 1)
	{
		printf("Signature Verify Success\n");
	}
	else
	{
		printf("Signature Verify Fail\n");
	}

	//測試SHA256
	char shaHashResult[(512 / 8) * 2 + 1]; //最多512 bits，因為要記錄成hex，所以*2，再加1是為了放'\0'
	int shaHashResultLen;
	shaHash(SHA2_256, message, shaHashResult, &shaHashResultLen);
	printf("SHA256 = %s\n", shaHashResult);
	//測試SHA384
	shaHash(SHA2_384, message, shaHashResult, &shaHashResultLen);
	printf("SHA384 = %s\n", shaHashResult);
	//測試SHA512
	shaHash(SHA2_512, message, shaHashResult, &shaHashResultLen);
	printf("SHA512 = %s\n", shaHashResult);

	/*
	char bytes[32];
	char* hex = "4A5B";
	int len;
	hex_to_bytes(hex, bytes, &len);
	printf("len = %d\n", len);
	for (int i = 0; i < len; i++)
	{
		printf("%02X", bytes[i]);
	}
	printf("\n");
	for (int i = 0; i < len; i++)
	{
		printf("%d ", bytes[i]);
	}
	char hex2[50];
	bytes_to_hex(bytes, len, hex2);
	printf("\nhex2 = %s\n", hex2);

	return 0;*/
}

